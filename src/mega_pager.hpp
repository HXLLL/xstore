#pragma once

#include "page_addr.hpp"
#include "mousika/learned_index.h"

#include <vector>

namespace fstore {

/*!
  Maintains the mapping between page_id + offset -> meage_id + offset.
  Compared to page_id, mega_id + offset maintains the true relationship between different pages.
  For example, when using mega_id, if page0 <- page1, then mega_id0 < mega_id1.

  The following is the mega page table.

       |   Mega 01   |   Mega 02   |  .....   |
      /               \
      | page_id x, page_id y, xxx | ....
      ** u32, u32, xxxx           **

  So the question now becomes, how to calculate the mega id ?
*/
//typedef u32 mega_id_t;
using mega_id_t = u64;
class MegaPager {
 public:
  static constexpr int offset_bits = 8;
  static constexpr int id_bits     = sizeof(mega_id_t) * 8 - offset_bits;

  static constexpr u32 invalid_page_id = std::numeric_limits<u32>::max();

  typedef PageID<offset_bits + id_bits,id_bits> PPageID;

  MegaPager() = default;

  MegaPager(u32 expected_sz) {
    all_ids_.reserve(expected_sz);
  }

  void reset() {
    all_ids_.clear();
  }

  /*!
    Create the MegaPager from a raw data buffer.
    This is useful as a client receiving the MegaPager from the server.
    \param buf: the buf generated by another MegaPager by calling serialize_to_buf().
   */
  MegaPager(const std::string &buf) {
    not_implemented();
  }

  /*!
    Insert an entry to mega page table, return its encoded mega_id_addr.
    \param page_id: the possible "new" page_id to be inserted.
    \return the mega page id of this specific page.
  */
  mega_id_t emplace(u32 page_id,u32 offset = 0) {
    // sanity check that the offset is not overflowed
    assert(offset < ((2 << offset_bits) - 1));
    if(all_ids_.empty() || all_ids_.back() != page_id) {
      all_ids_.push_back(page_id);
    }
    return PPageID::encode(all_ids_.size() - 1,offset);
  }

  /*!
    Return the page id corresponding to the mega_id.
    \param mega_id: the id generated from the emplace call.
    \return the real page_id of the page.
  */
  u32 get_page_id(mega_id_t mega_id) {
    auto elems = PPageID::decode_id(mega_id);
    //assert(elems < all_ids_.size());
    if(elems >= all_ids_.size())
      return invalid_page_id;
    return all_ids_[elems];
  }

  /*!
    returns a serialization of *all_ids_*.
  */
  std::string serialize_to_buf() const {
    not_implemented();
    return "";
  }

  /*!
    returns the number of mapped pages by this mega.
  */
  u64 total_num() const {
    return all_ids_.size();
  }

  /*!
    check whether a predicted pos of a given key fits within one mega page.
    \param: predict returned by the learned_index.predict_pos.
  */
  bool within_page(const Predicts &predict) {
    return page_span(predict) == 1;
  }

  int page_span(const Predicts &predict) {
    ASSERT(predict.start <= predict.pos);
    ASSERT(predict.pos <= predict.end);
    if(get_page_id(predict.end) == invalid_page_id
       || get_page_id(predict.start) == invalid_page_id)
      return -1;
    mega_id_t id0, id1;
    return (get_page_id(predict.end) - get_page_id(predict.start)) + 1;
  }

 private:
  std::vector<u32> all_ids_;
};

} // end namespace fstore
