#pragma once

#include "common.hpp"
#include "marshal.hpp"

#include "mousika/learned_index.h"

#include <vector>

namespace fstore {

//using page_entry_t = u32;
using page_entry_t = u64;

/*!
  Maintains the mapping between page_id + offset -> meage_id + offset.
  Compared to page_id, mega_id + offset maintains the true relationship between
  different pages. For example, when using mega_id, if page0 <- page1, then
  mega_id0 < mega_id1.

  The following is the mega page table.

       |   Mega 01   |   Mega 02   |  .....   |
      /               \
      | page_id x, page_id y, xxx | ....
      ** u32, u32, xxxx           **

  So the question now becomes, how to calculate the mega id ?
*/

using mega_id_t = page_entry_t;

constexpr page_entry_t invalid_page_id = std::numeric_limits<page_entry_t>::max();

/*!
  We assume that each page has fixed entries, defined with *PAGE_ENTRY*.
 */
template<typename PAGE_TYPE>
class MegaPagerV
{
public:
  static constexpr page_entry_t PAGE_ENTRY = PAGE_TYPE::page_entry();

  MegaPagerV() = default;

  MegaPagerV(u32 expected_sz) { all_ids_.reserve(expected_sz); }

  /*!
    Create the MegaPager from a raw data buffer.
    This is useful as a client receiving the MegaPager from the server.
    \param buf: the buf generated by another MegaPager by calling
    serialize_to_buf().
  */
  MegaPagerV(const std::string& buf)
  {
    const char* cur_ptr = buf.data();
    u64 cur_size = buf.size();
    while (cur_size >= sizeof(page_entry_t)) {
      auto res = Marshal<page_entry_t>::deserialize_opt(cur_ptr, cur_size);
      if (res) {
        all_ids_.push_back(res.value());
        cur_size -= sizeof(page_entry_t);
        cur_ptr += sizeof(page_entry_t);
      } else
        break;
    }
  }

  void reset() { all_ids_.clear(); }

  /*!
    Insert a page in the mapping table.
    \param page_id: the page id to store the value.
    \param offset:  the offset of value in this page.
    \param total:   total keys in this page. If the *offset* is the
    last entry in this page, this page id will be emplace to this MegaPagerV.
    \return the range of mega_id_t recorded by this mega
   */
  mega_id_t emplace(page_entry_t page_id, page_entry_t offset, int total)
  {
    auto entry = all_ids_.size();
    if (offset == total - 1) {
      all_ids_.push_back(page_id);
    }
    assert(offset < PAGE_ENTRY);
    // LOG(4) << "entry: " << entry << "; offset: " << offset;
    return entry * PAGE_ENTRY + offset;
  }

  /*!
    Return the page id corresponding to the mega_id.
    \param mega_id: the id generated from the emplace call.
    \return the real page_id of the page.
  */
  page_entry_t get_page_id(mega_id_t mega_id)
  {
    auto res = decode_mega_to_entry(mega_id);
    if (res >= all_ids_.size())
      return invalid_page_id;
    return mapped_page_id(res);
  }

  page_entry_t decode_mega_to_entry(mega_id_t mega_id) const
  {
    return mega_id / PAGE_ENTRY;
  }

  page_entry_t mapped_page_id(const page_entry_t &entry) const
  {
    ASSERT(entry < all_ids_.size()) << "total ids: " << all_ids_.size()
                                    << " invalid entry: " << entry;
    return all_ids_[entry];
  }

  void invalid_page_entry(const page_entry_t& entry) { all_ids_[entry] = 0; }

  usize num_invalid_entries() const {
    usize sum = 0;
    for(uint i = 0;i < all_ids_.size();++i) {
      if(all_ids_[i] == 0)
        sum += 1;
      LOG(4) << "entry: " << i << " content: " << all_ids_[i];
    }
    return sum;
  }

  page_entry_t get_offset(mega_id_t mega_id) const { return mega_id % PAGE_ENTRY; }

  /*!
    check whether a predicted pos of a given key fits within one mega page.
    \param: predict returned by the learned_index.predict_pos.
  */
  bool within_page(const Predicts& predict) { return page_span(predict) == 1; }

  int page_span(const Predicts& predict)
  {
    // XD: according to TCZ, the pos can out of the range
    if (predict.end < predict.start)
      return -1;
    if (get_page_id(predict.end) == invalid_page_id ||
        get_page_id(predict.start) == invalid_page_id)
      return -1;
    mega_id_t id0, id1;
    return (get_page_id(predict.end) - get_page_id(predict.start)) + 1;
  }

  /*!
    returns a serialization of *all_ids_*.
  */
  std::string serialize_to_buf() const
  {
    std::string res(sizeof(page_entry_t) * all_ids_.size(), '0');
    char* cur_ptr = (char*)res.data();
    for (auto v : all_ids_) {
      cur_ptr = Marshal<page_entry_t>::serialize_to(v, cur_ptr);
    }
    return res;
  }

  /*!
    returns the number of mapped pages by this mega.
  */
  u64 total_num() const { return all_ids_.size(); }

  u64 page_table_size() const { return all_ids_.size() * sizeof(page_entry_t); }

  std::vector<page_entry_t> all_ids_;
};

} // end namespace fstore
