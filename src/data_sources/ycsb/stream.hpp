#pragma once

#include "../../common.hpp"
#include "../../datastream/stream.hpp"
#include "hash.hpp"

namespace fstore {

namespace sources {

namespace  ycsb {

class YCSBGenerator : public datastream::StreamIterator<u64,u64> {
 public:
  /*!
    Generate key-value pairs according to YCSB distribution.
    YCSB uses linear key space, the generator will generate keys from [start,end].
    Note, YCSB uses uint64_t key.
    XD: what about value?
  */
  YCSBGenerator(u64 start,u64 end,u64 seed = 0xdeadbeaf) :
      start(start), end(end),rand(seed),current_loaded_(start) {
    assert(end >= start);
  }

  void begin() override {
    current_loaded_ = start;
  }

  bool valid() override {
    return current_loaded_ < end;
  }

  void next() override {
    current_loaded_ += 1;
  }

  u64 key() override {
    return current_loaded_;
  }

  u64 value() override {
    return rand.next();
  }

 public:
  const u64 start;
  const u64 end;
 private:
  r2::util::FastRandom rand;
  u64 current_loaded_ = 0;
};

/*!
  The hasher, hash the key generated by YCSBHashgenereator, so that the key space is not linear.
 */
class YCSBHashGenereator : public datastream::StreamIterator<u64,u64> {
 public:
  YCSBHashGenereator(u64 start,u64 end,u64 seed = 0xdeadbeaf) :
      core(start,end,seed) {
  }

  void begin() override {
    core.begin();
  }

  bool valid() override {
    return core.valid();
  }

  u64 key() override {
    return Hasher::hash(core.key());
  }

  u64 value() override {
    return core.value();
  }

  void next() override {
    max_key = std::max(key(),max_key);
    return core.next();
  }

 private:
  YCSBGenerator core;
  u64 max_key = 0;
};

} // end namespace YCSB

}

} // end namespace fstore
